In VS Code:

Select Python Interpreter (VERY IMPORTANT)
Press: Ctrl + Shift + P
Select: Python: Select Interpreter
Choose:
System Python, or
Virtual environment Python (env/bin/python)




def foo(x):
    y = 10 * x + 2
    return y

print (foo(10))  # 102




name = input("Enter your name: ")
print(name)


WAP in Python to define and use a function. The function prompts the user to enter his/her name and prints :
"Hello!, Welcome " + name + "!!"



hello.py

def disp_name():
    name=input("Enter your name:")
    print("Hello!, Welcome " + name + "!!")

def add(x,y):
    return x+y

# disp_name()
# add(3,4)


Add a new file in current folder as useHello.py

import hello

hello.disp_name()



abc.py

x = 10   # global

def test():
    y = 5   # local
    print(x)




x = 10   # global

def test():
    y = 5   # local
    print(x)
    print(y)

print(y)
print(x)




x = 10   # global

def test():
    y = 5   # local
    print(x)
    print(y)

# print(y)
print(x)
test()




x = 10   # global

def test():
    y = 5   # local
    x=20
    print(x)
    print(y)

# print(y)
print(x)
test()






def add(x,y):
    print("x: "+ str(x))
    print("y: "+ str(y))
    return x + y

print(add(3,4))


def add(x,y):
    print("x: "+ str(x))
    print("y: "+ str(y))
    return x + y

print(add(3,4))

print(add(x=3,y=4))

print(add(y=3,x=4))





There may be several types of arguments which can be passed at the time of function call.
Required arguments
Keyword arguments
Default arguments
Variable-length arguments : *var, **Kwargs




def add(x,y):
    print("x: "+ str(x))
    print("y: "+ str(y))
    return x + y

print(add(3,4))

print(add(x=3,y=4))

print(add(y=3,x=4))


# print(add(3))  ###TypeError: add() missing 1 required positional argument: 'y'





def add(x,y=6):
    print("x: "+ str(x))
    print("y: "+ str(y))
    return x + y

print(add(3,4))

print(add(x=3,y=4))

print(add(y=3,x=4))


# print(add(3))  ###TypeError: add() missing 1 required positional argument: 'y'


print(add(3))

__________________________________________


l1=[1,2,3]
print(l1)
print(type(l1))
l1.append(4)
print(l1)
print(type(l1))

t1=(1,2,3)
print(t1)
print(type(t1))
# t1.append(4)

______________________________

def printme(*names):    
    print("type of passed argument is ",type(names))  
    # names.append("John")  
    print("printing the passed arguments...")    
    for name in names:    
        print(name)    

printme("john","David","smith","nick") 
printme(1,3,"HHH")   

_______________

def printme(names):    
    print("type of passed argument is ",type(names))  
    names.append("John")  
    print("printing the passed arguments...")    
    for name in names:    
        print(name)    

printme(["john","David","smith","nick"]) 
printme([1,3,"HHH"])   





____________________________


def printme(names):    
    print("type of passed argument is ",type(names))  
    # names.append("John")  
    print("printing the passed arguments...")    
    for name in names:    
        print(name)    

printme(tuple(["john","David","smith","nick"])) 
printme([1,3,"HHH"])   






def func(name1,message,name2):    
    print("printing the message with",name1,",",message,", and",name2)    

func(name1="John", message="hello", name2="David")   
func("Johny",message="hello",name2="David")   
#the Johny is not the keyword argument
func("John",message="hello","David")   
#will cause an error due to an in-proper mix of keyword and required arguments being passed in the function call. 



def func(name1,message,name2):    
    print("printing the message with",name1,",",message,", and",name2)    

func(name1="John", message="hello", name2="David")   
func("Johny",message="hello",name2="David")
#the Johny is not the keyword argument
# func("John",name2="hello","David")
#will cause an error due to an in-proper mix of keyword and required arguments being passed in the function call. 



#Many arguments using Keyword argument
def food(**kwargs):  
    print(type(kwargs))
    print(kwargs)  

food(a="Apple")  
food(fruits="Orange", Vegetables="Carrot") 
# food('veg')  #Error
food()






_____________________________


#Many arguments using Keyword argument
def emplist(emps):
    print("the table: ")
    for emp in emps:
        print(emp)

emplist([{"name":"John","sal":20,"desig":"IT"},
         {"name":"Jane","sal":25,"desig":"HR"}])

____________


Packing (Tuple Packing)
def total_marks(*marks):
    print(marks)

total_marks(80, 85, 90)
Arguments packed into a tuple
Unpacking (Tuple Unpacking)
scores = (80, 85, 90)
total_marks(*scores)
Dictionary Unpacking
def employee(name, salary):
    print(name, salary)

data = {"name": "John", "salary": 50000}
employee(**data)




WAP in python to create a function summation which takes multiple parameters using variable arguments(*args)
The program should show usages:
summation(2,3)
summation(4,5,6,7,8)
summation(6,"abc")  ##should give error
summation("Abc","def")




def add_numbers(*args):
    total = 0
    for num in args:
        total += num
    return total

add_numbers(1, 2, 3, 4)

Rule : Arguments before /:
Cannot be passed as keyword
Must be positional
Syntax
def func(a, b, /):
    pass
Example
def divide(a, b, /):
    return a / b

divide(10, 2)          # Valid
divide(a=10, b=2)      # TypeError
Why Use It?
Protect API from misuse
Match C-API / built-in functions
Prevent breaking changes
Example from Python itself:
len([1, 2, 3])    # positional-only


___________________________________



def divide(a, b, /):
    return a / b

divide(10, 2)          # Valid
# divide(a=10, b=2)      # TypeError




Arguments after *:
Must be passed as keyword
Cannot be positional
Syntax
def connect(*, host, port):
    pass
Example
def connect(*, host, port):
    print(host, port)

connect(host="localhost", port=5432)   # Correct
connect("localhost", 5432)             # TypeError
With Mixed Arguments
def create_user(username, *, is_admin=False):
    print(username, is_admin)

create_user("alice", is_admin=True)    # Correct
create_user("alice", True)             # Error




def divide(*, a, b):
    return a / b

# divide(10, 2)           # TypeError
divide(a=10, b=2)     









Full Syntax Pattern
def func(pos1, pos2, /, standard, *, kw1, kw2):
    pass
Example
def api_call(endpoint, method, /, retries=3, *, timeout, secure=True):
    print(endpoint, method, retries, timeout, secure)
Valid Call
api_call(
    "/users",
    "GET",
    retries=2,
    timeout=10,
    secure=False
)
Invalid Calls
api_call(endpoint="/users", method="GET", timeout=10)  # Error
api_call("/users", "GET", 2, 10)                        # Error






def api_call(endpoint, method, /, retries=3, *, timeout, secure=True):
    print(endpoint, method, retries, timeout, secure)

api_call("/users","GET", retries=2, timeout=10, secure=False)
api_call("/users","GET", timeout=10, secure=False)

def api_call(endpoint, method, /, retries, *, timeout, secure=True):
    print(endpoint, method, retries, timeout, secure)

api_call("/users","GET", retries=2, timeout=10, secure=False)
api_call("/users","GET", 4, timeout=10, secure=False)


_______________________


1 Default Arguments
def add(a, b, c=0):
    return a + b + c

add(2, 3)
add(2, 3, 4)
2 Variable Arguments (*args)
def add(*args):
    return sum(args)

add(2, 3)
add(2, 3, 4, 5)




3 Conditional Logic
def area(x, y=None):
    if y:
        return x * y
    return x * x
4 functools.singledispatch (Real Overloading)
from functools import singledispatch

@singledispatch
def process(data):
    print("Default processing")

@process.register(int)
def _(data):
    print("Integer processing")

@process.register(str)
def _(data):
    print("String processing")




from functools import singledispatch

@singledispatch
def process(data):
    print("Default processing")

@process.register(int)
def _(data):
    print("Integer processing")

@process.register(str)
def _(data):
    print("String processing")


process(8.9)
process(8)
process("aa")



___________________________



def count_up(n):
    for i in range(1, n + 1):
        yield i
#Usage:
for num in count_up(3):
    print(num)


def count_up(n):
    return range(1, n + 1)

#Usage:
for num in count_up(3):
    print(num)

___________________________


What Is an Iterator?
An object that:
Implements __iter__()
Implements __next__()
Built-in Iterator Example
numbers = [1, 2, 3]
it = iter(numbers)
print(next(it))
print(next(it))
Custom Iterator
class CountDown:
    def __init__(self, start):
        self.start = start

    def __iter__(self):
        return self

    def __next__(self):
        if self.start <= 0:
            raise StopIteration
        self.start -= 1
        return self.start + 1




class Countdown:
    def __init__(self, start):
        self.start = start

    def __iter__(self):
        return self

    def __next__(self):
        if self.start <= 0:
            raise StopIteration
        self.start -= 1
        return self.start + 1

for num in Countdown(3):
    print(num)  #3 2 1

______________________________

class Countdown:
    def __init__(self, start):
        self.start = start

    def __iter__(self):
        return self

    def __next__(self):
        if self.start <= 0:
            raise StopIteration
        self.start -= 2
        return self.start + 2

for num in Countdown(30):
    print(num, end=" ")  #30 28 26 24 22 20 18 16 14 12 10 8 6 4 2






def demo():
    print("Start",end=" ")
    yield 1
    print("Resume",end=" ")
    yield 2

for n in demo():
    print(n,end=" ")




nums = [1, 2, 3]
it = iter(nums)

print(list(it))   # [1, 2, 3]
print(list(it))   # []




_______________

def fact(x):
	if(x>1):
		return x * fact(x-1)
	else:
		return 1

	
factorial=fact(5)
print(factorial)
#120




_______________

Syntax
lambda arguments: expression       


# Function definition is here
sum = lambda arg1, arg2: arg1 + arg2;

# Now you can call sum as a function
print("Value of total : ", sum( 10, 20 ))
print("Value of total : ", sum( 20, 20 ))

Output:
Value of total :  30
Value of total :  40




#the function table(n) prints the table of n    
def table(n):    
    return lambda a:a*n 

n = int(input("Enter the number:"))    

b = table(n) 
#the entered number is passed into the function table. b will now contain a lambda function

for i in range(1,11):    
    print(n,"X",i,"=",b(i)) 
#the lambda function b is called with the iteration variable i  

_______________________________


#Consider the following example where we filter out the only odd number from the given list.

#program to filter out the tuple which contains odd numbers    
lst = (10,22,37,41,100,123,29)  

oddlist = tuple(filter(lambda x:(x%2 == 1),lst)) 

# the tuple contains all the items of the tuple for which the lambda function evaluates to true    

print(oddlist)    

#Output:
#(37, 41, 123, 29)



___________________________


#program to map the list and get its square    
lst = [10,20,30,40,50,60]

square_list = list(map(lambda x:x**2,lst)) 

# the tuple contains all the items of the list for which the lambda function returns another list with square of each element of the list    

print(square_list)    

#Output:
#[100, 400, 900, 1600, 2500, 3600]



____________________________________

Lists:


# List declaration
my_list = [10, 20, 30, 40, 50]
print("Original List:", my_list)

# Properties of lists
print("\nProperties:")
print("Length of list:", len(my_list))  # Length of the list
print("Minimum value in the list:", min(my_list))  # Minimum value
print("Maximum value in the list:", max(my_list))  # Maximum value
print("Sum of all elements in the list:", sum(my_list))  # Sum of elements

# Operations on lists
print("\nOperations:")
my_list.append(60)  # Append an element
print("After appending 60:", my_list)

my_list.extend([70, 80])  # Extend the list
print("After extending with [70, 80]:", my_list)

my_list.insert(2, 25)  # Insert at a specific position
print("After inserting 25 at index 2:", my_list)

popped_value = my_list.pop(3)  # Pop an element at index 3
print("After popping value at index 3:", my_list)
print("Popped value:", popped_value)

my_list.remove(25)  # Remove the first occurrence of a value
print("After removing 25:", my_list)

print("Index of 40:", my_list.index(40))  # Find index of an element

print("Count of 40:", my_list.count(40))  # Count occurrences of a value

my_list.reverse()  # Reverse the list
print("After reversing the list:", my_list)

my_list.sort()  # Sort the list
print("After sorting the list:", my_list)

# List slicing
print("\nSlicing:")
print("First three elements:", my_list[:3])
print("Elements from index 2 to 5:", my_list[2:5])
print("Last three elements:", my_list[-3:])

# List concatenation and repetition
print("\nConcatenation and Repetition:")
another_list = [100, 200]
concatenated_list = my_list + another_list  # Concatenate two lists
print("Concatenated list:", concatenated_list)

repeated_list = my_list * 2  # Repeat the list
print("Repeated list:", repeated_list)

# List comprehension
print("\nList Comprehension:")
squared_list = [x ** 2 for x in my_list]
print("Squares of elements:", squared_list)

# Copying a list
print("\nCopying:")
copied_list = my_list.copy()  # Copy the list
print("Copied list:", copied_list)

# Clearing a list
my_list.clear()  # Clear all elements
print("After clearing the list:", my_list)


______________________________________

Tuple:


# Tuple declaration
my_tuple = (10, 20, 30, 40, 50)
print("Original Tuple:", my_tuple)

# Properties of tuples
print("\nProperties:")
print("Length of tuple:", len(my_tuple))  # Length of the tuple
print("Minimum value in the tuple:", min(my_tuple))  # Minimum value
print("Maximum value in the tuple:", max(my_tuple))  # Maximum value
print("Sum of all elements in the tuple:", sum(my_tuple))  # Sum of elements

# Accessing elements
print("\nAccessing Elements:")
print("First element:", my_tuple[0])  # Access the first element
print("Last element:", my_tuple[-1])  # Access the last element
print("Slice from index 1 to 3:", my_tuple[1:4])  # Slice elements
print("Every second element:", my_tuple[::2])  # Step through elements

# Tuple concatenation and repetition
print("\nConcatenation and Repetition:")
another_tuple = (60, 70)
concatenated_tuple = my_tuple + another_tuple  # Concatenate two tuples
print("Concatenated tuple:", concatenated_tuple)

repeated_tuple = my_tuple * 2  # Repeat the tuple
print("Repeated tuple:", repeated_tuple)

# Tuple methods
print("\nTuple Methods:")
print("Count of 20 in tuple:", my_tuple.count(20))  # Count occurrences
print("Index of 30 in tuple:", my_tuple.index(30))  # Find index of a value

# Unpacking tuples
print("\nUnpacking Tuples:")
a, b, c, d, e = my_tuple  # Unpacking the tuple into variables
print("Unpacked values:", a, b, c, d, e)

# Nesting tuples
nested_tuple = (my_tuple, another_tuple)
print("\nNested Tuple:", nested_tuple)

# Membership tests
print("\nMembership Tests:")
print("Is 20 in the tuple?", 20 in my_tuple)  # Check membership
print("Is 100 not in the tuple?", 100 not in my_tuple)

# Immutable property of tuples
print("\nImmutability:")
try:
    my_tuple[0] = 99  # Attempt to modify an element
except TypeError as e:
    print("Error:", e)

# Tuple comprehension using generator expressions
print("\nTuple Comprehension (via Generator):")
squared_tuple = tuple(x ** 2 for x in my_tuple)
print("Squares of elements:", squared_tuple)





