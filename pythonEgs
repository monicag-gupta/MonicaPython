In VS Code:

Select Python Interpreter (VERY IMPORTANT)
Press: Ctrl + Shift + P
Select: Python: Select Interpreter
Choose:
System Python, or
Virtual environment Python (env/bin/python)




def foo(x):
    y = 10 * x + 2
    return y

print (foo(10))  # 102




name = input("Enter your name: ")
print(name)


WAP in Python to define and use a function. The function prompts the user to enter his/her name and prints :
"Hello!, Welcome " + name + "!!"



hello.py

def disp_name():
    name=input("Enter your name:")
    print("Hello!, Welcome " + name + "!!")

def add(x,y):
    return x+y

# disp_name()
# add(3,4)


Add a new file in current folder as useHello.py

import hello

hello.disp_name()



abc.py

x = 10   # global

def test():
    y = 5   # local
    print(x)




x = 10   # global

def test():
    y = 5   # local
    print(x)
    print(y)

print(y)
print(x)




x = 10   # global

def test():
    y = 5   # local
    print(x)
    print(y)

# print(y)
print(x)
test()




x = 10   # global

def test():
    y = 5   # local
    x=20
    print(x)
    print(y)

# print(y)
print(x)
test()






def add(x,y):
    print("x: "+ str(x))
    print("y: "+ str(y))
    return x + y

print(add(3,4))


def add(x,y):
    print("x: "+ str(x))
    print("y: "+ str(y))
    return x + y

print(add(3,4))

print(add(x=3,y=4))

print(add(y=3,x=4))





There may be several types of arguments which can be passed at the time of function call.
Required arguments
Keyword arguments
Default arguments
Variable-length arguments : *var, **Kwargs




def add(x,y):
    print("x: "+ str(x))
    print("y: "+ str(y))
    return x + y

print(add(3,4))

print(add(x=3,y=4))

print(add(y=3,x=4))


# print(add(3))  ###TypeError: add() missing 1 required positional argument: 'y'





def add(x,y=6):
    print("x: "+ str(x))
    print("y: "+ str(y))
    return x + y

print(add(3,4))

print(add(x=3,y=4))

print(add(y=3,x=4))


# print(add(3))  ###TypeError: add() missing 1 required positional argument: 'y'


print(add(3))

__________________________________________


l1=[1,2,3]
print(l1)
print(type(l1))
l1.append(4)
print(l1)
print(type(l1))

t1=(1,2,3)
print(t1)
print(type(t1))
# t1.append(4)

______________________________

def printme(*names):    
    print("type of passed argument is ",type(names))  
    # names.append("John")  
    print("printing the passed arguments...")    
    for name in names:    
        print(name)    

printme("john","David","smith","nick") 
printme(1,3,"HHH")   

_______________

def printme(names):    
    print("type of passed argument is ",type(names))  
    names.append("John")  
    print("printing the passed arguments...")    
    for name in names:    
        print(name)    

printme(["john","David","smith","nick"]) 
printme([1,3,"HHH"])   





____________________________


def printme(names):    
    print("type of passed argument is ",type(names))  
    # names.append("John")  
    print("printing the passed arguments...")    
    for name in names:    
        print(name)    

printme(tuple(["john","David","smith","nick"])) 
printme([1,3,"HHH"])   






def func(name1,message,name2):    
    print("printing the message with",name1,",",message,", and",name2)    

func(name1="John", message="hello", name2="David")   
func("Johny",message="hello",name2="David")   
#the Johny is not the keyword argument
func("John",message="hello","David")   
#will cause an error due to an in-proper mix of keyword and required arguments being passed in the function call. 



def func(name1,message,name2):    
    print("printing the message with",name1,",",message,", and",name2)    

func(name1="John", message="hello", name2="David")   
func("Johny",message="hello",name2="David")
#the Johny is not the keyword argument
# func("John",name2="hello","David")
#will cause an error due to an in-proper mix of keyword and required arguments being passed in the function call. 



#Many arguments using Keyword argument
def food(**kwargs):  
    print(type(kwargs))
    print(kwargs)  

food(a="Apple")  
food(fruits="Orange", Vegetables="Carrot") 
# food('veg')  #Error
food()






_____________________________


#Many arguments using Keyword argument
def emplist(emps):
    print("the table: ")
    for emp in emps:
        print(emp)

emplist([{"name":"John","sal":20,"desig":"IT"},
         {"name":"Jane","sal":25,"desig":"HR"}])

____________


Packing (Tuple Packing)
def total_marks(*marks):
    print(marks)

total_marks(80, 85, 90)
Arguments packed into a tuple
Unpacking (Tuple Unpacking)
scores = (80, 85, 90)
total_marks(*scores)
Dictionary Unpacking
def employee(name, salary):
    print(name, salary)

data = {"name": "John", "salary": 50000}
employee(**data)




WAP in python to create a function summation which takes multiple parameters using variable arguments(*args)
The program should show usages:
summation(2,3)
summation(4,5,6,7,8)
summation(6,"abc")  ##should give error
summation("Abc","def")




def add_numbers(*args):
    total = 0
    for num in args:
        total += num
    return total

add_numbers(1, 2, 3, 4)

Rule : Arguments before /:
Cannot be passed as keyword
Must be positional
Syntax
def func(a, b, /):
    pass
Example
def divide(a, b, /):
    return a / b

divide(10, 2)          # Valid
divide(a=10, b=2)      # TypeError
Why Use It?
Protect API from misuse
Match C-API / built-in functions
Prevent breaking changes
Example from Python itself:
len([1, 2, 3])    # positional-only


___________________________________



def divide(a, b, /):
    return a / b

divide(10, 2)          # Valid
# divide(a=10, b=2)      # TypeError




Arguments after *:
Must be passed as keyword
Cannot be positional
Syntax
def connect(*, host, port):
    pass
Example
def connect(*, host, port):
    print(host, port)

connect(host="localhost", port=5432)   # Correct
connect("localhost", 5432)             # TypeError
With Mixed Arguments
def create_user(username, *, is_admin=False):
    print(username, is_admin)

create_user("alice", is_admin=True)    # Correct
create_user("alice", True)             # Error




def divide(*, a, b):
    return a / b

# divide(10, 2)           # TypeError
divide(a=10, b=2)     









Full Syntax Pattern
def func(pos1, pos2, /, standard, *, kw1, kw2):
    pass
Example
def api_call(endpoint, method, /, retries=3, *, timeout, secure=True):
    print(endpoint, method, retries, timeout, secure)
Valid Call
api_call(
    "/users",
    "GET",
    retries=2,
    timeout=10,
    secure=False
)
Invalid Calls
api_call(endpoint="/users", method="GET", timeout=10)  # Error
api_call("/users", "GET", 2, 10)                        # Error






def api_call(endpoint, method, /, retries=3, *, timeout, secure=True):
    print(endpoint, method, retries, timeout, secure)

api_call("/users","GET", retries=2, timeout=10, secure=False)
api_call("/users","GET", timeout=10, secure=False)

def api_call(endpoint, method, /, retries, *, timeout, secure=True):
    print(endpoint, method, retries, timeout, secure)

api_call("/users","GET", retries=2, timeout=10, secure=False)
api_call("/users","GET", 4, timeout=10, secure=False)


_______________________


1 Default Arguments
def add(a, b, c=0):
    return a + b + c

add(2, 3)
add(2, 3, 4)
2 Variable Arguments (*args)
def add(*args):
    return sum(args)

add(2, 3)
add(2, 3, 4, 5)




3 Conditional Logic
def area(x, y=None):
    if y:
        return x * y
    return x * x
4 functools.singledispatch (Real Overloading)
from functools import singledispatch

@singledispatch
def process(data):
    print("Default processing")

@process.register(int)
def _(data):
    print("Integer processing")

@process.register(str)
def _(data):
    print("String processing")




from functools import singledispatch

@singledispatch
def process(data):
    print("Default processing")

@process.register(int)
def _(data):
    print("Integer processing")

@process.register(str)
def _(data):
    print("String processing")


process(8.9)
process(8)
process("aa")



___________________________



def count_up(n):
    for i in range(1, n + 1):
        yield i
#Usage:
for num in count_up(3):
    print(num)


def count_up(n):
    return range(1, n + 1)

#Usage:
for num in count_up(3):
    print(num)


