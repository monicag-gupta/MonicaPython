unittest is Python’s built-in unit testing framework, inspired by JUnit. It helps you automatically test your application logic and catch bugs early.
1. Setup and Configurations
Importing unittest
import unittest
Basic project structure
project/
├── app.py
└── test_app.py
2. Discuss the Application Under Test (AUT)
Application Under Test (AUT) is the code you want to verify.
app.py


def add(a, b):
    return a + b

def divide(a, b):
    if b == 0:
        raise ValueError("Division by zero")
    return a / b


3. Basics of unittest
Key Concepts
TestCase: A class containing test methods
Test Method: A method starting with test_
Assertion: Checks expected vs actual
Test Runner: Executes tests
Common Assertions
self.assertEqual(a, b)
self.assertNotEqual(a, b)
self.assertTrue(x)
self.assertFalse(x)
self.assertIsNone(x)
self.assertIn(item, collection)
self.assertRaises(Exception)



4. Structure and Functioning
Basic Test Structure

test_app.py



import unittest
from app import add, divide

class TestMathOperations(unittest.TestCase):

    def test_add(self):
        self.assertEqual(add(2, 3), 5)

    def test_divide(self):
        self.assertEqual(divide(10, 2), 5)

    def test_divide_by_zero(self):
        with self.assertRaises(ValueError):
            divide(10, 0)

if __name__ == "__main__":
    unittest.main()



5. Cmd Line Options and Test Discovery
Run a test file
python -m unittest test_app.py
Verbose output
python -m unittest -v test_app.py
Test discovery (recommended)
python -m unittest discover
With pattern:
python -m unittest discover -s . -p "test_*.py"




6. Fixtures in Tests
Fixtures handle setup and cleanup.
Method-level fixtures
class TestWithFixtures(unittest.TestCase):
    def setUp(self):
        print("Setup before each test")
    def tearDown(self):
        print("Cleanup after each test")
    def test_one(self):
        self.assertTrue(True)
Class-level fixtures
class TestClassFixtures(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        print("Runs once before all tests")
    @classmethod
    def tearDownClass(cls):
        print("Runs once after all tests")





hello.py

def add(a, b):
    return a + b

def divide(a, b):
    if b == 0:
        raise ValueError("Division by zero")
    return a / b





import unittest
from hello import add, divide

class TestMathOperations(unittest.TestCase):
    def test_add(self):
        print("Testing add...")
        self.assertEqual(add(2, 3), 5)
    def test_divide(self):
        print("Testing divide...")
        self.assertEqual(divide(10, 2), 5)
    def test_divide_by_zero(self):
        print("Testing divide by 0...")
        with self.assertRaises(ValueError):
            divide(10, 0)
    def setUp(self):
        print("Setup before each test")
    def tearDown(self):
        print("Cleanup after each test")
    def test_one(self):
        print("Testing own function simple...")
        self.assertTrue(True)
    @classmethod
    def setUpClass(cls):
        print("Runs once before all tests")
    @classmethod
    def tearDownClass(cls):
        print("Runs once after all tests")
    def test_even_numbers(self):
        print("Testing Own test function even nos...")
        for num in [2, 4, 6, 8]:
            with self.subTest(num=num):
                self.assertEqual(num % 2, 0)

if __name__ == "__main__":
    unittest.main()




8. Running Tests Programmatically
Useful when integrating tests into scripts or CI tools.
import unittest

def run_tests():
    suite = unittest.TestLoader().discover('.')
    runner = unittest.TextTestRunner(verbosity=2)
    runner.run(suite)

if __name__ == "__main__":
    run_tests()


unittest Lifecycle
setUpClass()
 └── setUp()
     └── test_method()
 └── tearDown()
tearDownClass()







import unittest
from hello import add, divide

class TestMathOperations(unittest.TestCase):
    def test_add(self):
        print("Testing add...")
        self.assertEqual(add(2, 3), 5)
    def test_divide(self):
        print("Testing divide...")
        self.assertEqual(divide(10, 2), 5)
    def test_divide_by_zero(self):
        print("Testing divide by 0...")
        with self.assertRaises(ValueError):
            divide(10, 0)
    def setUp(self):
        print("Setup before each test")
    def tearDown(self):
        print("Cleanup after each test")
    def test_one(self):
        print("Testing own function simple...")
        self.assertTrue(True)
    @classmethod
    def setUpClass(cls):
        print("Runs once before all tests")
    @classmethod
    def tearDownClass(cls):
        print("Runs once after all tests")
    def test_even_numbers(self):
        print("Testing Own test function even nos...")
        for num in [2, 4, 6, 8]:
            with self.subTest(num=num):
                self.assertEqual(num % 2, 0)

# if __name__ == "__main__":
#     unittest.main()

def run_tests():
    suite = unittest.TestLoader().discover('.')
    runner = unittest.TextTestRunner(verbosity=2)
    runner.run(suite)

if __name__ == "__main__":
    run_tests()




Fake (Test Double)
Real code we want to test

def process(reader):
    return reader.read().upper()

Fake object (Test Double)
class FakeReader:
    def read(self):
        return "hello world"

Test using Fake
def test_process_with_fake():
    reader = FakeReader()     # test double
    result = process(reader)
    assert result == "HELLO WORLD"

No real file
No database
Fully controlled input




def process(reader):
    """
    Expects an object that provides a read() method.
    """
    return reader.read().upper()

# process() depends on reader
# reader could be a file, DB, API, etc.
# We don’t want real dependencies in tests

# Decide the Test Double type
# We’ll use:
# Fake → simple replacement
# Mock → verify interaction

# Create a Fake (Test Double)
class FakeReader:
    def read(self):
        return "hello world"

# Fake behaves like the real object
# No external dependency

# Write test using Fake
def test_process_with_fake():
    reader = FakeReader()     # test double
    result = process(reader)
    assert result == "HELLO WORLD"

# Test passes
# Logic tested in isolation
# Run the Fake test: From terminal:
# pytest test_service_fake.py
# Fast, Reliable, No setup required




pip install pytest

pytest .\test_app.py







Mock (Test Double)
Real code we want to test
def process(reader):
    return reader.read().upper()
Use a Mock (Behavior-based testing)
Simple Mock Example (using unittest.mock)
from unittest.mock import Mock
def test_process_with_mock():
    reader = Mock()
    reader.read.return_value = "hello"
    result = process(reader)
    assert result == "HELLO"
    reader.read.assert_called_once()
Why Mock is useful
Avoid slow dependencies
Verify behavior (method called or not)
Keep tests fast and isolated





from unittest.mock import Mock
def process(reader):
    """
    Expects an object that provides a read() method.
    """
    return reader.read().upper()

# process() depends on reader
# reader could be a file, DB, API, etc.
# We don’t want real dependencies in tests

# Use a Mock (Behavior-based testing)
# Now let’s verify:
# “Was read() actually called?”

# Create Mock object
def test_process_with_mock():
    reader = Mock()
    reader.read.return_value = "hello"
    # No class needed
    # Behavior is configured dynamically
    # Call the function
    result = process(reader)
    # Assertions
    assert result == "HELLO"
    reader.read.assert_called_once()
    # Checks result
    # Verifies interaction
# Run the Mock test
# pytest test_service_mock.py





A Dummy object is passed to a function but is never actually used.


# Dummy Object – Simple Example
# Code under test
def send_message(service, message):
    return "Message sent"
# service is required as a parameter but not used at all.

# Dummy object
class DummyService:
    pass

# Test using Dummy
def test_send_message_with_dummy():
    dummy = DummyService()   # dummy object
    result = send_message(dummy, "Hello")
    assert result == "Message sent"
# Why this is a Dummy
# Passed only to satisfy the function signature
#  No behavior
#  Never called
#  No logic inside





A Stub provides predefined responses to method calls during testing.


# Stub Object – Simple Example
# Code under test
def get_greeting(user):
    user.get_name()
    return f"Hello Jay"

# Stub object
class StubUser:
    def get_name(self):
        pass
        #return "Jay"   # fixed, predefined value

# Test using Stub
def test_get_greeting_with_stub():
    user = StubUser()   # stub
    result = get_greeting(user)
    assert result == "Hello Jay"
# Why this is a Stub
# Returns controlled data
# No real user object needed
# Used to drive the code path




SPY:
A Spy records how a method was used while allowing the real behavior to run.


# Spy Object – Simple Example
# Code under test
def process(reader):
    return reader.read().upper()

# Spy (using Mock)
from unittest.mock import Mock

def test_process_with_spy():
    reader = Mock()                 # spy
    reader.read.return_value = "hello"
    result = process(reader)
    assert result == "HELLO"
    reader.read.assert_called_once()   # spying on behavior

# Why this is a Spy
# It records method calls
# Verifies interaction (read() called once)
# Observes behavior, not just output



patch() replaces objects temporarily during tests.
Example: Mocking an API Call : app.py
import requests
def get_status():
    response = requests.get("https://api.example.com")
    return response.status_code
test_app.py
import unittest
from unittest.mock import patch
from app import get_status
class TestAPI(unittest.TestCase):
    @patch("app.requests.get")
    def test_get_status(self, mock_get):
        mock_get.return_value.status_code = 200
        result = get_status()
        self.assertEqual(result, 200)
        mock_get.assert_called_once()
Patch where it is used, not where it is defined.



pip install requests


import requests
def get_status():
    response = requests.get("https://api.example.com")
    return response.status_code
#If the function were in service.py, then you MUST patch: @patch("service.requests.get")

import unittest
from unittest.mock import patch

class TestAPI(unittest.TestCase):
    @patch("requests.get")
    def test_get_status(self, mock_get):  # requests.get = Mock()
        mock_get.return_value.status_code = 200  #Configure the mock
        #When requests.get() is called…Return a fake response object, Whose status_code is 200
        #So this line inside get_status():response = requests.get(...) actually becomes: response = mock_get()
        result = get_status()
        # get_status() is NOT mocked Only its dependency (requests.get) is mocked. This is correct unit testing
        self.assertEqual(result, 200)
        mock_get.assert_called_once()







# Simple patch Example
# Code under test
# service.py
import time

def get_current_time():
    return time.time()

# Test using patch
from unittest.mock import patch
# from service import get_current_time

def test_get_current_time():
    # with patch("service.time.time", return_value=12345):
    with patch("time.time", return_value=12345):
        result = get_current_time()
        assert result == 12345

# What just happened?
# time.time() is real code
# patch("service.time.time") replaces it
# Only active inside the with block
# After the block → original behavior restored
# Key rule: Patch where it is USED, not where it is defined
# patch("service.time.time")  # correct
# patch("time.time")          # wrong







# Example (function patch)
# utils.py
def greet():
    return "Hello"

# Test
from unittest.mock import patch
# from utils import greet

def test_greet():
    # with patch("utils.greet", return_value="Hi"):
    with patch("greet", return_value="Hi"):
        assert greet() == "Hi"

# patch temporarily replaces a real object with a fake one during testing.




app.py

def greet():
    return "Hello"





# Example (function patch)
# utils.py
# def greet():
#     return "Hello"

# Test
from unittest.mock import patch
# from utils import greet
import app

def test_greet():
    # with patch("utils.greet", return_value="Hi"):
    with patch("app.greet", return_value="Hi"):
        assert app.greet() == "Hi"

# patch temporarily replaces a real object with a fake one during testing.





# Simple Monkey Patch Example
# Original code
class Calculator:
    def add(self, a, b):
        return a + b

# Monkey patch it
def fake_add(self, a, b):
    return 100

Calculator.add = fake_add   # monkey patch

# Use it
calc = Calculator()
print(calc.add(2, 3))   # 100 (not 5!)

# What happened?
# Original add() replaced at runtime
# All Calculator objects now use fake_add
# Change stays until program ends





Method-Level Parameterization. Concept
Parameters are supplied to a single test method
Each input combination becomes a separate test case
A) Method-Level Parameterization using unittest : Using subTest (Standard way)
import unittest
def add(a, b):
    return a + b
class TestAdd(unittest.TestCase):
    def test_add(self):
        test_data = [
            (1, 2, 3),
            (5, 5, 10),
            (-1, 1, 0)
        ]
        for a, b, expected in test_data:
            with self.subTest(a=a, b=b):
                self.assertEqual(add(a, b), expected)
if __name__ == "__main__":
    unittest.main()




B) Method-Level Parameterization using pytest
Using @pytest.mark.parametrize
import pytest
def add(a, b):
    return a + b
@pytest.mark.parametrize(
    "a,b,expected",
    [
        (1, 2, 3),
        (5, 5, 10),
        (-1, 1, 0),
    ]
)
def test_add(a, b, expected):
    assert add(a, b) == expected
Why pytest is popular
Cleaner syntax
Each case shown as a separate test
Better reporting







import pytest
def add(a, b):
    return a + b
@pytest.mark.parametrize(
    "a,b,expected",
    [
        (1, 2, 3),
        (5, 5, 0),  #deliberately failed
        (-1, 1, 0),
    ]
)
def test_add(a, b, expected):
    assert add(a, b) == expected







Concept
Entire test class is run multiple times
Each class instance gets different parameters
A) Class-Level Parameterization in pytest : Example
import pytest
def multiply(a, b):
    return a * b
@pytest.mark.parametrize(
    "a,b,expected",
    [
        (2, 3, 6),
        (5, 5, 25),
        (1, 0, 0),
    ]
)
class TestMultiply:
    def test_multiply(self, a, b, expected):
        assert multiply(a, b) == expected
    def test_positive_result(self, a, b, expected):
        assert expected >= 0
What happens?
Class is instantiated once per parameter set
All methods share the same parameters





import pytest
def multiply(a, b):
    return a * b
@pytest.mark.parametrize(
    "a,b,expected",
    [
        (2, -3, -6),  # positivity failed
        (5, 5, 20),   # result failed
        (1, 0, 0),
    ]
)
class TestMultiply:
    def test_multiply(self, a, b, expected):
        assert multiply(a, b) == expected
    def test_positive_result(self, a, b, expected):
        assert expected >= 0





Test Execution
What is Test Execution?
Test execution is the process of:
Discovering tests
Running them
Capturing results (pass / fail / error / skip)
A) Test Execution in unittest
Run a single test file
python -m unittest test_math.py
Run with verbose output
python -m unittest -v test_math.py
Test discovery
python -m unittest discover
Programmatic Execution
import unittest
loader = unittest.TestLoader()
suite = loader.discover(".")
runner = unittest.TextTestRunner(verbosity=2)
runner.run(suite)
Used in CI pipelines
Used for custom runners





B) Enhanced Reporting (unittest)
Using verbosity=2
unittest.TextTestRunner(verbosity=2)
Gives:
Test names
Clear status
Error trace
C) Reporting in pytest (Much richer)
FAILED test_math.py::test_divide
assert 5 == 4
Extra pytest reporting options
pytest --tb=short     # Short traceback
pytest --tb=long      # Full traceback
pytest --durations=5  # Slowest tests
pytest --maxfail=2





def test_add():
    assert 2 + 2 == 4

def test_subtract():
    assert 5 - 3 == 1   #  fail

def test_multiply():
    assert 2 * 3 == 5   #  fail

def test_divide():
    assert 10 / 2 == 5  # will NOT run if maxfail=2

