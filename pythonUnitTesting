unittest is Python’s built-in unit testing framework, inspired by JUnit. It helps you automatically test your application logic and catch bugs early.
1. Setup and Configurations
Importing unittest
import unittest
Basic project structure
project/
├── app.py
└── test_app.py
2. Discuss the Application Under Test (AUT)
Application Under Test (AUT) is the code you want to verify.
app.py


def add(a, b):
    return a + b

def divide(a, b):
    if b == 0:
        raise ValueError("Division by zero")
    return a / b


3. Basics of unittest
Key Concepts
TestCase: A class containing test methods
Test Method: A method starting with test_
Assertion: Checks expected vs actual
Test Runner: Executes tests
Common Assertions
self.assertEqual(a, b)
self.assertNotEqual(a, b)
self.assertTrue(x)
self.assertFalse(x)
self.assertIsNone(x)
self.assertIn(item, collection)
self.assertRaises(Exception)



4. Structure and Functioning
Basic Test Structure

test_app.py



import unittest
from app import add, divide

class TestMathOperations(unittest.TestCase):

    def test_add(self):
        self.assertEqual(add(2, 3), 5)

    def test_divide(self):
        self.assertEqual(divide(10, 2), 5)

    def test_divide_by_zero(self):
        with self.assertRaises(ValueError):
            divide(10, 0)

if __name__ == "__main__":
    unittest.main()



5. Cmd Line Options and Test Discovery
Run a test file
python -m unittest test_app.py
Verbose output
python -m unittest -v test_app.py
Test discovery (recommended)
python -m unittest discover
With pattern:
python -m unittest discover -s . -p "test_*.py"




6. Fixtures in Tests
Fixtures handle setup and cleanup.
Method-level fixtures
class TestWithFixtures(unittest.TestCase):
    def setUp(self):
        print("Setup before each test")
    def tearDown(self):
        print("Cleanup after each test")
    def test_one(self):
        self.assertTrue(True)
Class-level fixtures
class TestClassFixtures(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        print("Runs once before all tests")
    @classmethod
    def tearDownClass(cls):
        print("Runs once after all tests")





hello.py

def add(a, b):
    return a + b

def divide(a, b):
    if b == 0:
        raise ValueError("Division by zero")
    return a / b





import unittest
from hello import add, divide

class TestMathOperations(unittest.TestCase):
    def test_add(self):
        print("Testing add...")
        self.assertEqual(add(2, 3), 5)
    def test_divide(self):
        print("Testing divide...")
        self.assertEqual(divide(10, 2), 5)
    def test_divide_by_zero(self):
        print("Testing divide by 0...")
        with self.assertRaises(ValueError):
            divide(10, 0)
    def setUp(self):
        print("Setup before each test")
    def tearDown(self):
        print("Cleanup after each test")
    def test_one(self):
        print("Testing own function simple...")
        self.assertTrue(True)
    @classmethod
    def setUpClass(cls):
        print("Runs once before all tests")
    @classmethod
    def tearDownClass(cls):
        print("Runs once after all tests")
    def test_even_numbers(self):
        print("Testing Own test function even nos...")
        for num in [2, 4, 6, 8]:
            with self.subTest(num=num):
                self.assertEqual(num % 2, 0)

if __name__ == "__main__":
    unittest.main()




8. Running Tests Programmatically
Useful when integrating tests into scripts or CI tools.
import unittest

def run_tests():
    suite = unittest.TestLoader().discover('.')
    runner = unittest.TextTestRunner(verbosity=2)
    runner.run(suite)

if __name__ == "__main__":
    run_tests()


unittest Lifecycle
setUpClass()
 └── setUp()
     └── test_method()
 └── tearDown()
tearDownClass()







import unittest
from hello import add, divide

class TestMathOperations(unittest.TestCase):
    def test_add(self):
        print("Testing add...")
        self.assertEqual(add(2, 3), 5)
    def test_divide(self):
        print("Testing divide...")
        self.assertEqual(divide(10, 2), 5)
    def test_divide_by_zero(self):
        print("Testing divide by 0...")
        with self.assertRaises(ValueError):
            divide(10, 0)
    def setUp(self):
        print("Setup before each test")
    def tearDown(self):
        print("Cleanup after each test")
    def test_one(self):
        print("Testing own function simple...")
        self.assertTrue(True)
    @classmethod
    def setUpClass(cls):
        print("Runs once before all tests")
    @classmethod
    def tearDownClass(cls):
        print("Runs once after all tests")
    def test_even_numbers(self):
        print("Testing Own test function even nos...")
        for num in [2, 4, 6, 8]:
            with self.subTest(num=num):
                self.assertEqual(num % 2, 0)

# if __name__ == "__main__":
#     unittest.main()

def run_tests():
    suite = unittest.TestLoader().discover('.')
    runner = unittest.TextTestRunner(verbosity=2)
    runner.run(suite)

if __name__ == "__main__":
    run_tests()




Fake (Test Double)
Real code we want to test

def process(reader):
    return reader.read().upper()

Fake object (Test Double)
class FakeReader:
    def read(self):
        return "hello world"

Test using Fake
def test_process_with_fake():
    reader = FakeReader()     # test double
    result = process(reader)
    assert result == "HELLO WORLD"

No real file
No database
Fully controlled input




def process(reader):
    """
    Expects an object that provides a read() method.
    """
    return reader.read().upper()

# process() depends on reader
# reader could be a file, DB, API, etc.
# We don’t want real dependencies in tests

# Decide the Test Double type
# We’ll use:
# Fake → simple replacement
# Mock → verify interaction

# Create a Fake (Test Double)
class FakeReader:
    def read(self):
        return "hello world"

# Fake behaves like the real object
# No external dependency

# Write test using Fake
def test_process_with_fake():
    reader = FakeReader()     # test double
    result = process(reader)
    assert result == "HELLO WORLD"

# Test passes
# Logic tested in isolation
# Run the Fake test: From terminal:
# pytest test_service_fake.py
# Fast, Reliable, No setup required




pip install pytest

pytest .\test_app.py







Mock (Test Double)
Real code we want to test
def process(reader):
    return reader.read().upper()
Use a Mock (Behavior-based testing)
Simple Mock Example (using unittest.mock)
from unittest.mock import Mock
def test_process_with_mock():
    reader = Mock()
    reader.read.return_value = "hello"
    result = process(reader)
    assert result == "HELLO"
    reader.read.assert_called_once()
Why Mock is useful
Avoid slow dependencies
Verify behavior (method called or not)
Keep tests fast and isolated





from unittest.mock import Mock
def process(reader):
    """
    Expects an object that provides a read() method.
    """
    return reader.read().upper()

# process() depends on reader
# reader could be a file, DB, API, etc.
# We don’t want real dependencies in tests

# Use a Mock (Behavior-based testing)
# Now let’s verify:
# “Was read() actually called?”

# Create Mock object
def test_process_with_mock():
    reader = Mock()
    reader.read.return_value = "hello"
    # No class needed
    # Behavior is configured dynamically
    # Call the function
    result = process(reader)
    # Assertions
    assert result == "HELLO"
    reader.read.assert_called_once()
    # Checks result
    # Verifies interaction
# Run the Mock test
# pytest test_service_mock.py





A Dummy object is passed to a function but is never actually used.


# Dummy Object – Simple Example
# Code under test
def send_message(service, message):
    return "Message sent"
# service is required as a parameter but not used at all.

# Dummy object
class DummyService:
    pass

# Test using Dummy
def test_send_message_with_dummy():
    dummy = DummyService()   # dummy object
    result = send_message(dummy, "Hello")
    assert result == "Message sent"
# Why this is a Dummy
# Passed only to satisfy the function signature
#  No behavior
#  Never called
#  No logic inside





A Stub provides predefined responses to method calls during testing.


# Stub Object – Simple Example
# Code under test
def get_greeting(user):
    user.get_name()
    return f"Hello Jay"

# Stub object
class StubUser:
    def get_name(self):
        pass
        #return "Jay"   # fixed, predefined value

# Test using Stub
def test_get_greeting_with_stub():
    user = StubUser()   # stub
    result = get_greeting(user)
    assert result == "Hello Jay"
# Why this is a Stub
# Returns controlled data
# No real user object needed
# Used to drive the code path




SPY:

# Spy Object – Simple Example
# Code under test
def process(reader):
    return reader.read().upper()

# Spy (using Mock)
from unittest.mock import Mock

def test_process_with_spy():
    reader = Mock()                 # spy
    reader.read.return_value = "hello"
    result = process(reader)
    assert result == "HELLO"
    reader.read.assert_called_once()   # spying on behavior

# Why this is a Spy
# It records method calls
# Verifies interaction (read() called once)
# Observes behavior, not just output










