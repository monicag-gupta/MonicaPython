class Employee:
   'Common base class for all employees'
   empCount = 0

   def __init__(self, name, salary):
      self.name = name
      self.salary = salary
      Employee.empCount += 1
   
   def displayCount(self):
     print ("Total Employee %d" % Employee.empCount)

   def displayEmployee(self):
      print ("Name : ", self.name,  ", Salary: ", self.salary)

#"This would create first object of Employee class"
emp1 = Employee("Jay", 10000)
# "This would create second object of Employee class"
emp2 = Employee("Monica", 5000)
emp1.displayEmployee()
emp2.displayEmployee()
print ("Total Employee %d" % Employee.empCount)

print ("Employee.__doc__:", Employee.__doc__)
# Employee.__doc__: Common base class for all employees

print ("Employee.__name__:", Employee.__name__)
# Employee.__name__: Employee

print ("Employee.__module__:", Employee.__module__)
# Employee.__module__: EmployeeClass

print ("Employee.__bases__:", Employee.__bases__)
# Employee.__bases__: (<class 'object'>,)

print ("Employee.__dict__:", Employee.__dict__)
# Employee.__dict__: {'__module__': 'EmployeeClass', '__doc__': 'Common base class for all employees', 'empCount': 2, '__init__': <function Employee.__init__ at 0x02E3ADF0>, 'displayCount': <function Employee.displayCount at 0x02E3ADA8>, 'displayEmployee': <function Employee.displayEmployee at 0x02E3AD60>, '__dict__': <attribute '__dict__' of 'Employee' objects>, '__weakref__': <attribute '__weakref__' of 'Employee' objects>}






___________



class Point:
   def __init__( self, x=0, y=0):
      self.x = x
      self.y = y
   def __del__(self):
      class_name = self.__class__.__name__
      print (class_name, "destroyed")

pt1 = Point()
print (id(pt1)) # prints the ids of the objects
del pt1


Output
3083401324 
Point destroyed



________________



class Animal:  
    def speak(self):  
        print("Animal Speaking")  

#child class Dog inherits the base class Animal  

class Dog(Animal):  
    def bark(self):  
        print("dog barking")  


d = Dog()  
d.bark()  
d.speak()  

Output:
dog barking
Animal Speaking


_____________________


class Animal:  
    def speak(self):  
        print("Animal Speaking")  

#child class Dog inherits the base class Animal  

class Dog(Animal):  
    def bark(self):  
        print("dog barking")
    def walk(self):  
        print("dog walking")  


class Cat(Animal):  
    def meow(self):  
        print("cat meowing") 
    def walk(self):  
        print("cat walking")  


class BabyAnimal(Cat, Dog):
    pass

d = BabyAnimal()  
d.bark()  
d.speak() 
d.walk()
d.meow() 





_______________

class Animal:
    def __init__(self, name):
        self.name = name
        print(f"Animal created: {self.name}")
 
class Dog(Animal):
    def __init__(self, name, breed):
        super().__init__(name)   # calls Animal's __init__
        self.breed = breed
        print(f"Dog breed: {self.breed}")
 
d = Dog("Bruno", "Labrador")
# Animal created: Bruno
# Dog breed: Labrador


__________________

class Animal:
    def speak(self):
        print("Animal speaks")

class Dog(Animal):
    def speak(self):
        super().speak()         # Call the parent class method
        print("Dog barks")

d = Dog()
d.speak()
# Animal speaks
# Dog barks


______________________


class Calculation1:  
    def Summation(self,a,b):  
        return a+b;  
class Calculation2:  
    def Multiplication(self,a,b):  
        return a*b;  
class Derived(Calculation1,Calculation2):  
    def Divide(self,a,b):  
        return a/b;  

d = Derived()  
print(issubclass(Derived,Calculation2))  
print(issubclass(Calculation1,Calculation2))  

Output:
True
False

_____________

class Calculation1:  
    def Summation(self,a,b):  
        return a+b;  
class Calculation2:  
    def Multiplication(self,a,b):  
        return a*b;  
class Derived(Calculation1,Calculation2):  
    def Divide(self,a,b):  
        return a/b;  
d = Derived()  
print(isinstance(d,Derived)) 
print(isinstance(d,Calculation1)) 

Output:
True
True


_____________________



# If an object “quacks like a duck,” it can be used like a duck.
class Dog:
    def speak(self):
        print("Woof!")
 
class Cat:
    def speak(self):
        print("Meow!")
 
def make_sound(animal):
    animal.speak()


d=Dog()
make_sound(d)  # Woof!
make_sound(Cat())  # Meow!

# No need to check types — just call the method.

__________________



Suppose you have created a Vector class to represent two-dimensional vectors, what if we want to use the plus operator to add them.. For this we have to define the __add__ method in your class to perform vector addition and then the plus operator would behave as per expectation −

Example
class Vector:
   def __init__(self, a, b):
      self.a = a
      self.b = b
   def __str__(self):
      return 'Vector (%d, %d)' % (self.a, self.b)
   
   def __add__(self,other):
      return Vector(self.a + other.a, self.b + other.b)

v1 = Vector(2,10)
v2 = Vector(5,-2)
print (v1 + v2)

Output:
Vector(7,8)




class Vector:
   def __init__(self, a, b):
      self.a = a
      self.b = b
   def __str__(self):
      return 'Vector (' + str(self.a) + ', ' + str(self.b) + ')'
   
   def __add__(self,other):
      return Vector(self.a + other.a, self.b + other.b)

v1 = Vector(2,10)
v2 = Vector(5,-2)
print (v1 + v2)  # v1.__add__(v2)



________


class Vector:
   def __init__(self, a, b):
      self.a = a
      self.b = b
   def __str__(self):
      return 'Vector (' + str(self.a) + ', ' + str(self.b) + ')'
   
   def __add__(self,other):
      return Vector(self.a + other.a, self.b + other.b)

v1 = Vector(2,10)
v2 = Vector(5,-2)
v3=Vector(7,8)
print (v1 + v2 + v3)  # tv= v1.__add__(v2); tv.__add__(v3)
#(v1.add(v2).add(v3))

_______________________


Write a Python class to convert an integer to a roman numeral and a roman numeral to an integer
Write a Python class to reverse a string word by word.Input string : 'hello world'Expected Output : 'world hello'

Create a Bus child class that inherits from the Vehicle class. 
The default fare charge of any vehicle is seating capacity * 100. 
If Vehicle is Bus instance, we need to add an extra 10% on full fare as a maintenance charge. 
So total fare for bus instance will become the final amount = total fare + 10% of the total fare.
Note: The bus seating capacity is 50. so the final fare amount should be 5550. 
You need to override the fare() method of a Vehicle class in Bus class.
Expected Output:
Total Bus fare is: 5500.0


_________________________

Encapsulation:

class BankAccount:
    def __init__(self, owner, balance):
        self.owner = owner
        self.__balance = balance  # Private attribute

    # Getter
    @property
    def balance(self):
        return self.__balance

    # Setter
    @balance.setter
    def balance(self, amount):
        if amount >= 0:
            self.__balance = amount
        else:
            print("Balance cannot be negative!")

# Usage
account = BankAccount("Alice", 1000)
print(account.balance)  # Access via getter
account.balance = 2000  # Update via setter
print(account.balance)
account.balance = -500   # Invalid, setter prevents it
print(account.balance)


______________

Abstraction

from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

    @abstractmethod
    def perimeter(self):
        pass

# Concrete class
class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

    def perimeter(self):
        return 2 * (self.width + self.height)

# Usage
rect = Rectangle(5, 10)
print("Rectangle Area:", rect.area())
print("Rectangle Perimeter:", rect.perimeter())
#sh = Shape()
#print("Shape Area:", sh.area())
#print("Shape Perimeter:", sh.perimeter())




_________________________________________________



Pillars:

from abc import ABC, abstractmethod

# -----------------------------
# Abstraction & Encapsulation
# -----------------------------
class Vehicle(ABC):  # Abstract class
    def __init__(self, brand, max_speed):
        self._brand = brand      # Encapsulated (protected)
        self.__max_speed = max_speed  # Encapsulated (private)

    @abstractmethod
    def drive(self):
        """Abstract method: Must be implemented by subclasses"""
        pass

    # Getter for private variable
    @property
    def max_speed(self):
        return self.__max_speed

    # Setter for private variable
    @max_speed.setter
    def max_speed(self, speed):
        if speed > 0:
            self.__max_speed = speed
        else:
            print("Speed must be positive!")

# -----------------------------
# Inheritance & Polymorphism
# -----------------------------
class Car(Vehicle):  # Inherits from Vehicle
    def __init__(self, brand, max_speed, doors):
        super().__init__(brand, max_speed)
        self.doors = doors

    # Method Overriding (Polymorphism)
    def drive(self):
        print(f"{self._brand} car is driving at {self.max_speed} km/h with {self.doors} doors.")

class Bike(Vehicle):
    def drive(self):
        print(f"{self._brand} bike is riding at {self.max_speed} km/h.")

# -----------------------------
# Using the classes (Polymorphism in action)
# -----------------------------
vehicles = [Car("Toyota", 180, 4), Bike("Yamaha", 120)]

for v in vehicles:
    v.drive()  # Polymorphic call





________________


Composition (Has-A Relationship)

class Engine:
    def start(self):
        print("Engine started")

class Car:
    def __init__(self):
        self.engine = Engine()  # Composition: Car HAS-A Engine

    def start_car(self):
        self.engine.start()
        print("Car is ready to go")

my_car = Car()
my_car.start_car()

_________________


Aggregation (Weak Has-A Relationship)

class Student:
    def __init__(self, name):
        self.name = name

class Team:
    def __init__(self, members):
        self.members = members  # Aggregation

student1 = Student("Alice")
student2 = Student("Bob")

team = Team([student1, student2])
for member in team.members:
    print(member.name)



___________


Association (General Relationship)


class Driver:
    def __init__(self, name):
        self.name = name

    def drive(self, vehicle):
        print(f"{self.name} is driving {vehicle.model}")

class Vehicle:
    def __init__(self, model):
        self.model = model

driver = Driver("John")
car = Vehicle("Toyota")

driver.drive(car)  # Association: Driver uses Vehicle


___________________


Definition:
Identity is the unique identifier of an object in memory.
It remains constant during the object’s lifetime.
Obtained using the built-in id() function.
a = 10
b = 10

print(id(a))
print(id(b))
Output (may vary):
140715838203920
140715838203920
a and b refer to the same object (integer caching).
Identity with Mutable Objects
x = [1, 2, 3]
y = x

print(id(x))
print(id(y))
Both variables point to the same object.




Definition:
Type defines what kind of object it is.
Determines supported operations and behavior.
Checked using the type() function.
x = 10
y = 3.14
z = "Python"
w = [1, 2, 3]

print(type(x))
print(type(y))
print(type(z))
print(type(w))
Output:
<class 'int'>
<class 'float'>
<class 'str'>
<class 'list'>
Once created, an object’s type never changes.




Definition:
Value is the data stored inside the object.
Value can change for mutable objects, but not for immutable ones.
Immutable Object Example
a = 10
print(id(a))

a = a + 5
print(id(a))
A new object is created when value changes.
Mutable Object Example
lst = [1, 2, 3]
print(id(lst))

lst.append(4)
print(id(lst))
Value changed, identity stayed the same.


____________________



class LifeCycle:
    def __init__(self):
        print("Object created")

    def __del__(self):
        print("Object destroyed")

def demo():
    obj = LifeCycle()  # creates an object
    print("Object in use")
# scope of object ends, destroyed
demo()
print("End of program")


__________________________


class LifeCycle:
    def __init__(self):
        print("Object created")

    def abc():
        print("working of obj")

    def __del__(self):
        print("Object destroyed")

def demo():
    obj = LifeCycle()  # creates an object
    # del obj
    print("Object in use")
    obj.abc()
# scope of object ends, destroyed
demo()

print("End of program")



___________________________



A closure is:
A function that remembers variables from its enclosing scope, even after that scope is gone.
Basic Closure Example
def outer(msg):
    def inner():
        print(msg)
    return inner

f = outer("Hello")
f()      # Hello
msg is remembered even after outer() finishes.
Why Closures Matter
Data hiding
Function factories
Decorators
Lightweight alternatives to classes



def counter():
    count = 0

    def increment():
        nonlocal count
        count += 1
        return count

    return increment

c = counter()
print(c())   # 1
print(c())   # 2




A decorator is:
A function that wraps another function to add behavior without modifying its code
Function Decorator
def my_decorator(func):
    def wrapper():
        print("Before function")
        func()
        print("After function")
    return wrapper

@my_decorator
def greet():
    print("Hello")

greet()

Output:
Before function
Hello
After function

wrapper() is a closure



_____________


Decorator Accepting Arguments
def repeat(n):
    def decorator(func):
        def wrapper():
            for _ in range(n):
                func()
        return wrapper
    return decorator

@repeat(3)   # repeat(3)(say_hi)
def say_hi():
    print("Hi")

say_hi()    #repeat(3)(say_hi)() -> repeat(3) 's decorator(say_hi) -> wrapper()
Call Chain
say_hi → decorator → wrapper → func


_________________________

wraps is a decorator for decorators.
It is used to preserve the original function’s metadata when you wrap it with another function.
@wraps(func) copies these attributes:
__name__ : Function name
__doc__ : Docstring
__module__ :  Module name
__annotations__ : Type hints
__wrapped__ : Reference to original function



______________________

def logger(func):
    def wrapper(*args, **kwargs):
        print("Calling function")
        return func(*args, **kwargs)
    return wrapper

@logger
def add(a, b):
    """Adds two numbers"""
    return a + b

print(add.__name__)
print(add.__doc__)


_________________


from functools import wraps

def logger(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        print("Calling function")
        return func(*args, **kwargs)
    return wrapper

@logger
def add(a, b):
    """Adds two numbers"""
    return a + b

print(add.__name__)
print(add.__doc__)


___________________



def repeat(n):
    def decorator(func):
        def wrapper():
            for _ in range(n):
                func()
        return wrapper
    return decorator

@repeat(2)
def say_hi():
    print("Hi")


dec=repeat(3)
wraper=dec(say_hi)
wraper()  # inside the wrapper: say_hi is executed: 3 
# each time say_hi() -> it will run twice

#totally: 6 times


# say_hi()

@repeat(3)
@repeat(2)
def say_hi2():
    print("Hi2")

say_hi2()



_________________________


Decorator Use CasesLogging Decorator

def logger(func):
    """
    A decorator that logs the function name
    and arguments before calling the function.
    """
    def wrapper(*args, **kwargs):
        print(f"[LOG] Calling function: {func.__name__}")
        print(f"[LOG] Arguments: args={args}, kwargs={kwargs}")

        result = func(*args, **kwargs)   # Call the original function

        print(f"[LOG] Function {func.__name__} returned: {result}")
        return result

    return wrapper

# Using the Decorator
@logger
def add(a, b):
    return a + b

@logger
def greet(name):
    return f"Hello, {name}"

# Running the Code
add(10, 20)
print()
greet("Jay")


_______________


Decorator Use CasesTiming Function Execution 


import time
from functools import wraps

def timer(func):
    """
    Decorator that measures and prints
    the execution time of a function.
    """
    @wraps(func)
    def wrapper(*args, **kwargs):
        start = time.time()          # Start time
        result = func(*args, **kwargs)  # Call original function
        end = time.time()            # End time
        print(f"Execution time of {func.__name__}: {end - start:.6f} seconds")
        return result                # Return original result

    return wrapper

# Using the Decorator
@timer
def slow_add(a, b):
    time.sleep(1)   # Simulate slow computation
    return a + b

@timer
def fast_task():
    return sum(range(1000))

#Running the Code
result1 = slow_add(10, 20)
print("Result:", result1)

print()

result2 = fast_task()
print("Result:", result2)



Output:
Execution time of slow_add: 1.000443 seconds
Result: 30

Execution time of fast_task: 0.000111 seconds
Result: 499500



_____________

Decorator Use CasesAuthentication / Authorization Decorator

from functools import wraps

def requires_login(func):
    """
    Decorator that allows access only
    if the user is logged in.
    """
    @wraps(func)
    def wrapper(user, *args, **kwargs):
        if not user.get("logged_in"):
            raise PermissionError("Login required")
        return func(user, *args, **kwargs)

    return wrapper

# Function Protected by Decorator
@requires_login
def view_dashboard(user):
    return f"Welcome {user['username']} to your dashboard!"

# Running the Code

# Logged-in user
user1 = {
    "username": "jay",
    "logged_in": True
}

# Not logged-in user
user2 = {
    "username": "guest",
    "logged_in": False
}

# Authorized access
print(view_dashboard(user1))

print()

# Unauthorized access
try:
    print(view_dashboard(user2))
except PermissionError as e:
    print("Access denied:", e)



___________


Decorator Use CasesUpper Case Function Decorator


def uppercase(func):
    def wrapper():
        result = func()
        return result.upper()
    return wrapper

@uppercase
def message():
    return "hello world"

print(message())   # HELLO WORLD



____________________

There are three built-in decorators @staticmethod, @classmethod, and @property
@staticmethod → behaves like a normal function inside a class. Usage: Utility logic
@classmethod → modifies class state, not instance state. Usage: Alternative constructors
@property → enables attribute-style access with validation. @property removes need for explicit getters/setters. Usage: Validation & encapsulation



__________________________



class Employee:
    company = "OpenAI"   # Class variable

    def __init__(self, name, salary):
        self.name = name        # Instance variable
        self._salary = salary  # Protected (for property)

    # ----------------------------
    # @staticmethod
    # ----------------------------
    @staticmethod
    def is_valid_salary(salary):
        """
        Utility method.
        Does NOT access class or instance.
        """
        return salary > 0

    # ----------------------------
    # @classmethod
    # ----------------------------
    @classmethod
    def change_company(cls, new_name):
        """
        Operates on class data.
        """
        cls.company = new_name

    # ----------------------------
    # @property
    # ----------------------------
    @property
    def salary(self):
        """Getter"""
        return self._salary

    @salary.setter
    def salary(self, amount):
        """Setter with validation"""
        if amount <= 0:
            raise ValueError("Salary must be positive")
        self._salary = amount

#Using the Class
# Create object
emp = Employee("Jay", 50000)

# ----- staticmethod -----
print(Employee.is_valid_salary(10000))   # True
print(Employee.is_valid_salary(-5))      # False

# ----- classmethod -----
print(Employee.company)                  # OpenAI
Employee.change_company("TechCorp")
print(Employee.company)                  # TechCorp

# ----- property -----
print(emp.salary)                        # 50000
emp.salary = 60000                       # Calls setter
print(emp.salary)

# emp.salary = -1000   # Raises ValueError



__________________

__new__() and __init__()
__new__() : Creates the object (rarely overridden)
__init__() : Initializes the object (commonly used)
class Demo:
    def __new__(cls):
        print("__new__ called")
        return super().__new__(cls)

    def __init__(self):
        print("__init__ called")

obj = Demo()


self — Instance Reference
What is self?
Refers to the current object (instance)
Used to access instance variables and instance methods
Passed automatically to instance methods
cls — Class Reference
What is cls?
Refers to the class itself
Used in class methods
Passed automatically to methods decorated with @classmethod

self refers to the current object instance, while cls refers to the class itself and is used in class methods.




What it does
Creates a new instance of the class
Allocates memory for the object
Called before __init__()
Must return the newly created object
Key points
It is a static method (even though you don’t decorate it)
Used mainly when:
Subclassing immutable types (int, str, tuple)
Implementing singletons
Controlling object creation
Syntax
class MyClass:
    def __new__(cls):
        instance = super().__new__(cls)
        return instance



Subclassing int
class MyInt(int):
    def __new__(cls, value):
        print("Inside __new__")
        return super().__new__(cls, value)

    def __init__(self, value):
        print("Inside __init__")

num = MyInt(5)
Output
Inside __new__
Inside __init__
Value assignment must happen in __new__() for immutable types


class Singleton:
    _instance = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

a = Singleton()
b = Singleton()

print(a is b)  # True
Only one object is ever created


____

__new__() creates the object and allocates memory, while __init__() initializes the object after creation.
Rule of Thumb
Use __init__() → 99% of classes
Use __new__() → Immutables, Singleton, Metaclasses


_____


import re  

str="Hello Monica, How are you, how is life. How well goes coding"  
matches = re.findall("[Hh]ow", str)
print(matches)
# ['How', 'how', 'How']
matches = re.findall("How", str)
print(matches)
#['How', 'How']



The match object contains the information about the search and the output. If there is no match found, the None object is returned.

Example

import re  
  
str="Hello Monica, How are you, how is life"
matches = re.search("How", str)  
print(type(matches))  
print(matches) #matches is the search object 

Output:
<class '_sre.SRE_Match'>
<re.Match object; span=(14, 17), match='How'>


There are the following methods associated with the Match object.
span(): It returns the tuple containing the starting and end position of the match.
string(): It returns a string passed into the function.
group(): The part of the string is returned where the match is found.

Example
import re  
  
str = "Hello Monica. How are you. How is everything"  
matches = re.search("How", str)  
print(matches.span())  
print(matches.group())  
print(matches.string) 
Output:
(14, 17)
How
Hello Monica. How are you. How is everything





import re

str="Hello Monica, How are you, how is life"
matchObj = re.match( r'(.*) how (.*)', str, re.I)
print(matchObj.group())
print(matchObj.group(1))
print(matchObj.group(2))

Notice the r at the start of the pattern. This is called a raw string literal. It changes how the string literal is interpreted. Such literals are stored as they appear.
Output:
Hello Monica, How are you, how is life
Hello Monica, How are you,
is life















