class Employee:
   'Common base class for all employees'
   empCount = 0

   def __init__(self, name, salary):
      self.name = name
      self.salary = salary
      Employee.empCount += 1
   
   def displayCount(self):
     print ("Total Employee %d" % Employee.empCount)

   def displayEmployee(self):
      print ("Name : ", self.name,  ", Salary: ", self.salary)

#"This would create first object of Employee class"
emp1 = Employee("Jay", 10000)
# "This would create second object of Employee class"
emp2 = Employee("Monica", 5000)
emp1.displayEmployee()
emp2.displayEmployee()
print ("Total Employee %d" % Employee.empCount)

print ("Employee.__doc__:", Employee.__doc__)
# Employee.__doc__: Common base class for all employees

print ("Employee.__name__:", Employee.__name__)
# Employee.__name__: Employee

print ("Employee.__module__:", Employee.__module__)
# Employee.__module__: EmployeeClass

print ("Employee.__bases__:", Employee.__bases__)
# Employee.__bases__: (<class 'object'>,)

print ("Employee.__dict__:", Employee.__dict__)
# Employee.__dict__: {'__module__': 'EmployeeClass', '__doc__': 'Common base class for all employees', 'empCount': 2, '__init__': <function Employee.__init__ at 0x02E3ADF0>, 'displayCount': <function Employee.displayCount at 0x02E3ADA8>, 'displayEmployee': <function Employee.displayEmployee at 0x02E3AD60>, '__dict__': <attribute '__dict__' of 'Employee' objects>, '__weakref__': <attribute '__weakref__' of 'Employee' objects>}






___________



class Point:
   def __init__( self, x=0, y=0):
      self.x = x
      self.y = y
   def __del__(self):
      class_name = self.__class__.__name__
      print (class_name, "destroyed")

pt1 = Point()
print (id(pt1)) # prints the ids of the objects
del pt1


Output
3083401324 
Point destroyed



________________



class Animal:  
    def speak(self):  
        print("Animal Speaking")  

#child class Dog inherits the base class Animal  

class Dog(Animal):  
    def bark(self):  
        print("dog barking")  


d = Dog()  
d.bark()  
d.speak()  

Output:
dog barking
Animal Speaking


_____________________


class Animal:  
    def speak(self):  
        print("Animal Speaking")  

#child class Dog inherits the base class Animal  

class Dog(Animal):  
    def bark(self):  
        print("dog barking")
    def walk(self):  
        print("dog walking")  


class Cat(Animal):  
    def meow(self):  
        print("cat meowing") 
    def walk(self):  
        print("cat walking")  


class BabyAnimal(Cat, Dog):
    pass

d = BabyAnimal()  
d.bark()  
d.speak() 
d.walk()
d.meow() 





_______________

class Animal:
    def __init__(self, name):
        self.name = name
        print(f"Animal created: {self.name}")
 
class Dog(Animal):
    def __init__(self, name, breed):
        super().__init__(name)   # calls Animal's __init__
        self.breed = breed
        print(f"Dog breed: {self.breed}")
 
d = Dog("Bruno", "Labrador")
# Animal created: Bruno
# Dog breed: Labrador


__________________

class Animal:
    def speak(self):
        print("Animal speaks")

class Dog(Animal):
    def speak(self):
        super().speak()         # Call the parent class method
        print("Dog barks")

d = Dog()
d.speak()
# Animal speaks
# Dog barks


______________________


class Calculation1:  
    def Summation(self,a,b):  
        return a+b;  
class Calculation2:  
    def Multiplication(self,a,b):  
        return a*b;  
class Derived(Calculation1,Calculation2):  
    def Divide(self,a,b):  
        return a/b;  

d = Derived()  
print(issubclass(Derived,Calculation2))  
print(issubclass(Calculation1,Calculation2))  

Output:
True
False

_____________

class Calculation1:  
    def Summation(self,a,b):  
        return a+b;  
class Calculation2:  
    def Multiplication(self,a,b):  
        return a*b;  
class Derived(Calculation1,Calculation2):  
    def Divide(self,a,b):  
        return a/b;  
d = Derived()  
print(isinstance(d,Derived)) 
print(isinstance(d,Calculation1)) 

Output:
True
True


_____________________



# If an object “quacks like a duck,” it can be used like a duck.
class Dog:
    def speak(self):
        print("Woof!")
 
class Cat:
    def speak(self):
        print("Meow!")
 
def make_sound(animal):
    animal.speak()


d=Dog()
make_sound(d)  # Woof!
make_sound(Cat())  # Meow!

# No need to check types — just call the method.

__________________



Suppose you have created a Vector class to represent two-dimensional vectors, what if we want to use the plus operator to add them.. For this we have to define the __add__ method in your class to perform vector addition and then the plus operator would behave as per expectation −

Example
class Vector:
   def __init__(self, a, b):
      self.a = a
      self.b = b
   def __str__(self):
      return 'Vector (%d, %d)' % (self.a, self.b)
   
   def __add__(self,other):
      return Vector(self.a + other.a, self.b + other.b)

v1 = Vector(2,10)
v2 = Vector(5,-2)
print (v1 + v2)

Output:
Vector(7,8)




class Vector:
   def __init__(self, a, b):
      self.a = a
      self.b = b
   def __str__(self):
      return 'Vector (' + str(self.a) + ', ' + str(self.b) + ')'
   
   def __add__(self,other):
      return Vector(self.a + other.a, self.b + other.b)

v1 = Vector(2,10)
v2 = Vector(5,-2)
print (v1 + v2)  # v1.__add__(v2)



________


class Vector:
   def __init__(self, a, b):
      self.a = a
      self.b = b
   def __str__(self):
      return 'Vector (' + str(self.a) + ', ' + str(self.b) + ')'
   
   def __add__(self,other):
      return Vector(self.a + other.a, self.b + other.b)

v1 = Vector(2,10)
v2 = Vector(5,-2)
v3=Vector(7,8)
print (v1 + v2 + v3)  # tv= v1.__add__(v2); tv.__add__(v3)
#(v1.add(v2).add(v3))

_______________________


Write a Python class to convert an integer to a roman numeral and a roman numeral to an integer
Write a Python class to reverse a string word by word.Input string : 'hello world'Expected Output : 'world hello'

Create a Bus child class that inherits from the Vehicle class. 
The default fare charge of any vehicle is seating capacity * 100. 
If Vehicle is Bus instance, we need to add an extra 10% on full fare as a maintenance charge. 
So total fare for bus instance will become the final amount = total fare + 10% of the total fare.
Note: The bus seating capacity is 50. so the final fare amount should be 5550. 
You need to override the fare() method of a Vehicle class in Bus class.
Expected Output:
Total Bus fare is: 5500.0


_________________________

Encapsulation:

class BankAccount:
    def __init__(self, owner, balance):
        self.owner = owner
        self.__balance = balance  # Private attribute

    # Getter
    @property
    def balance(self):
        return self.__balance

    # Setter
    @balance.setter
    def balance(self, amount):
        if amount >= 0:
            self.__balance = amount
        else:
            print("Balance cannot be negative!")

# Usage
account = BankAccount("Alice", 1000)
print(account.balance)  # Access via getter
account.balance = 2000  # Update via setter
print(account.balance)
account.balance = -500   # Invalid, setter prevents it
print(account.balance)


______________

Abstraction

from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

    @abstractmethod
    def perimeter(self):
        pass

# Concrete class
class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

    def perimeter(self):
        return 2 * (self.width + self.height)

# Usage
rect = Rectangle(5, 10)
print("Rectangle Area:", rect.area())
print("Rectangle Perimeter:", rect.perimeter())
#sh = Shape()
#print("Shape Area:", sh.area())
#print("Shape Perimeter:", sh.perimeter())




_________________________________________________



Pillars:

from abc import ABC, abstractmethod

# -----------------------------
# Abstraction & Encapsulation
# -----------------------------
class Vehicle(ABC):  # Abstract class
    def __init__(self, brand, max_speed):
        self._brand = brand      # Encapsulated (protected)
        self.__max_speed = max_speed  # Encapsulated (private)

    @abstractmethod
    def drive(self):
        """Abstract method: Must be implemented by subclasses"""
        pass

    # Getter for private variable
    @property
    def max_speed(self):
        return self.__max_speed

    # Setter for private variable
    @max_speed.setter
    def max_speed(self, speed):
        if speed > 0:
            self.__max_speed = speed
        else:
            print("Speed must be positive!")

# -----------------------------
# Inheritance & Polymorphism
# -----------------------------
class Car(Vehicle):  # Inherits from Vehicle
    def __init__(self, brand, max_speed, doors):
        super().__init__(brand, max_speed)
        self.doors = doors

    # Method Overriding (Polymorphism)
    def drive(self):
        print(f"{self._brand} car is driving at {self.max_speed} km/h with {self.doors} doors.")

class Bike(Vehicle):
    def drive(self):
        print(f"{self._brand} bike is riding at {self.max_speed} km/h.")

# -----------------------------
# Using the classes (Polymorphism in action)
# -----------------------------
vehicles = [Car("Toyota", 180, 4), Bike("Yamaha", 120)]

for v in vehicles:
    v.drive()  # Polymorphic call





________________


Composition (Has-A Relationship)

class Engine:
    def start(self):
        print("Engine started")

class Car:
    def __init__(self):
        self.engine = Engine()  # Composition: Car HAS-A Engine

    def start_car(self):
        self.engine.start()
        print("Car is ready to go")

my_car = Car()
my_car.start_car()

_________________


Aggregation (Weak Has-A Relationship)

class Student:
    def __init__(self, name):
        self.name = name

class Team:
    def __init__(self, members):
        self.members = members  # Aggregation

student1 = Student("Alice")
student2 = Student("Bob")

team = Team([student1, student2])
for member in team.members:
    print(member.name)



___________


Association (General Relationship)


class Driver:
    def __init__(self, name):
        self.name = name

    def drive(self, vehicle):
        print(f"{self.name} is driving {vehicle.model}")

class Vehicle:
    def __init__(self, model):
        self.model = model

driver = Driver("John")
car = Vehicle("Toyota")

driver.drive(car)  # Association: Driver uses Vehicle


___________________


Definition:
Identity is the unique identifier of an object in memory.
It remains constant during the object’s lifetime.
Obtained using the built-in id() function.
a = 10
b = 10

print(id(a))
print(id(b))
Output (may vary):
140715838203920
140715838203920
a and b refer to the same object (integer caching).
Identity with Mutable Objects
x = [1, 2, 3]
y = x

print(id(x))
print(id(y))
Both variables point to the same object.




Definition:
Type defines what kind of object it is.
Determines supported operations and behavior.
Checked using the type() function.
x = 10
y = 3.14
z = "Python"
w = [1, 2, 3]

print(type(x))
print(type(y))
print(type(z))
print(type(w))
Output:
<class 'int'>
<class 'float'>
<class 'str'>
<class 'list'>
Once created, an object’s type never changes.




Definition:
Value is the data stored inside the object.
Value can change for mutable objects, but not for immutable ones.
Immutable Object Example
a = 10
print(id(a))

a = a + 5
print(id(a))
A new object is created when value changes.
Mutable Object Example
lst = [1, 2, 3]
print(id(lst))

lst.append(4)
print(id(lst))
Value changed, identity stayed the same.


____________________



class LifeCycle:
    def __init__(self):
        print("Object created")

    def __del__(self):
        print("Object destroyed")

def demo():
    obj = LifeCycle()  # creates an object
    print("Object in use")
# scope of object ends, destroyed
demo()
print("End of program")



