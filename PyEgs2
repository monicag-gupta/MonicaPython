from functools import reduce

# 1. Sum of All Elements
nums = [1, 2, 3, 4]
result = reduce(lambda x, y: x + y, nums)
print(result)  # Output: 10
# 2. Product of All Elements
nums = [1, 2, 3, 4]
product = reduce(lambda x, y: x * y, nums)
print(product)  # Output: 24
# 3. Finding Maximum
nums = [4, 1, 7, 3]
maximum = reduce(lambda x, y: x if x > y else y, nums)
print(maximum)  # Output: 7
# 4. Using an Initializer
nums = [1, 2, 3]
total = reduce(lambda x, y: x + y, nums, 10)
print(total)  # Output: 16 (10 + 1 + 2 + 3)



_________________________

# Example set
my_set = {10, 20, 30, 40, 50}
another_set = {30, 40, 50, 60, 70}
yet_another_set = {100, 200}

# Displaying the set (properties)
print("Original set:", my_set)

# 1. Basic Operations
my_set.add(60)  # Add an element
print("After adding 60:", my_set)

my_set.remove(20)  # Remove an element
print("After removing 20:", my_set)

my_set.discard(100)  # Discard an element (does not raise an error if not found)
print("After discarding 100:", my_set)

popped_element = my_set.pop()  # Remove and return a random element
print("Popped element:", popped_element)
print("After popping an element:", my_set)

my_set.clear()  # Clear the set
print("After clearing the set:", my_set)

# Reinitialize the set for further examples
my_set = {10, 20, 30, 40, 50}

# 2. Mathematical Operations
union_set = my_set.union(another_set)  # Union
print("Union of sets:", union_set)

intersection_set = my_set.intersection(another_set)  # Intersection
print("Intersection of sets:", intersection_set)

difference_set = my_set.difference(another_set)  # Difference
print("Difference of sets:", difference_set)

symmetric_difference_set = my_set.symmetric_difference(another_set)  # Symmetric Difference
print("Symmetric difference of sets:", symmetric_difference_set)

# 3. Methods for Comparison
is_disjoint = my_set.isdisjoint(yet_another_set)  # Check if disjoint
print("Is disjoint with yet_another_set?", is_disjoint)

is_subset = my_set.issubset(union_set)  # Check if subset
print("Is my_set a subset of union_set?", is_subset)

is_superset = union_set.issuperset(my_set)  # Check if superset
print("Is union_set a superset of my_set?", is_superset)

# 4. Other Methods
copied_set = my_set.copy()  # Copy the set
print("Copied set:", copied_set)

my_set.update(another_set)  # Update the set with another set
print("After updating my_set with another_set:", my_set)

my_set.intersection_update(another_set)  # Update with intersection
print("After intersection_update with another_set:", my_set)

my_set.difference_update(another_set)  # Update with difference
print("After difference_update with another_set:", my_set)

my_set.symmetric_difference_update(another_set)  # Update with symmetric difference
print("After symmetric_difference_update with another_set:", my_set)

# 5. Length and Membership Testing
my_set = {10, 20, 30, 40, 50}
print("Length of my_set:", len(my_set))  # Length of the set
print("Is 20 in my_set?", 20 in my_set)  # Membership testing
print("Is 100 not in my_set?", 100 not in my_set)  # Membership testing

# 6. Mathematical Operators
print("Union using |:", my_set | another_set)
print("Intersection using &:", my_set & another_set)
print("Difference using -:", my_set - another_set)
print("Symmetric difference using ^:", my_set ^ another_set)



_____________________________


Design a set of Employees’ empid
1001, 7003, 6002, 2000, 3050
Sort the set in ascending order
Display the set (sorted)
Hint: Convert the set to list. Sort it. Display.



____________________


# Example Dictionary
my_dict = { "name": "Alice", "age": 25, "skills": ["Python", "Data Analysis"], "is_student": False}

# Display the dictionary (properties)
print("Original Dictionary:", my_dict)

# 1. Accessing Values
print("Access 'name':", my_dict["name"])
print("Access with get('age'):", my_dict.get("age"))

# 2. Adding Key-Value Pairs
my_dict["city"] = "New York"
print("After adding city:", my_dict)

# 3. Updating Values
my_dict["age"] = 26
print("After updating age:", my_dict)

# 4. Deleting Key-Value Pairs
del my_dict["is_student"]
print("After deleting is_student:", my_dict)

# 5. Using pop() to remove an item
popped_item = my_dict.pop("city")
print("Popped item (city):", popped_item)
print("After popping city:", my_dict)

# 6. Using popitem() to remove the last inserted item
popped_item = my_dict.popitem()
print("Popped last item:", popped_item)
print("After popping last item:", my_dict)

# 7. Using setdefault() to get a value or set default
default_value = my_dict.setdefault("country", "USA")
print("Set default for 'country':", default_value)
print("After setdefault:", my_dict)

# 8. Merging Dictionaries
additional_data = {"hobby": "Reading", "profession": "Engineer"}
my_dict.update(additional_data)
print("After updating with additional_data:", my_dict)

# 9. Accessing Keys, Values, and Items
print("Keys:", my_dict.keys())
print("Values:", my_dict.values())
print("Items:", my_dict.items())

# 10. Iterating through the Dictionary
print("Iterating through keys and values:")
for key, value in my_dict.items():
    print(f"{key}: {value}")

# 11. Checking Key Existence
print("Is 'name' in my_dict?", "name" in my_dict)
print("Is 'salary' not in my_dict?", "salary" not in my_dict)

# 12. Copying the Dictionary
copied_dict = my_dict.copy()
print("Copied Dictionary:", copied_dict)

# 13. Clearing the Dictionary
my_dict.clear()
print("After clearing:", my_dict)


______________________________________


Compact syntax for creating collections.
List Comprehension
squares = [x*x for x in range(5)]
With condition:
even = [x for x in range(10) if x % 2 == 0]
Set Comprehension
unique_lengths = {len(word) for word in ["apple", "banana", "apple"]}
Dictionary Comprehension
squares = {x: x*x for x in range(5)}
With condition:
even_squares = {x: x*x for x in range(10) if x % 2 == 0}




squares = [x*x for x in range(5)]
print(squares)
even = [x for x in range(10) if x % 2 == 0]
print(even)
unique_lengths = {len(word) for word in ["apple", "banana", "apple"]}
print(unique_lengths)
squares = {x: x*x for x in range(5)}
print(squares)
even_squares = {x: x*x for x in range(10) if x % 2 == 0}
print(even_squares)


1. Create Dictionary from List
nums = [1, 2, 3, 4]
squares = {x: x*x for x in nums}
print(squares)
Output: {1: 1, 2: 4, 3: 9, 4: 16}
2. Using range() with conditions
even_cubes = {x: x**3 for x in range(10) if x % 2 == 0}
print(even_cubes)
Output: {0: 0, 2: 8, 4: 64, 6: 216, 8: 512}
3. Swapping Keys and Values
original = {'a': 1, 'b': 2, 'c': 3}
swapped = {v: k for k, v in original.items()}
print(swapped)
Output: {1: 'a', 2: 'b', 3: 'c'}



4. Filtering a Dictionary
data = {'apple': 3, 'banana': 5, 'cherry': 2, 'date': 7}
filtered = {k: v for k, v in data.items() if v > 3}
print(filtered)
Output: {'banana': 5, 'date': 7}
5. Nested Dictionary Comprehension
table = {x: {y: x*y for y in range(1, 6)} for x in range(1, 6)}
print(table)
Output (Partial): {1: {1: 1, 2: 2, 3: 3, 4: 4, 5: 5}, 2: {1: 2, 2: 4, ...}, ...}

_________________________________________

Write a Python program that performs the following tasks:
Create a dictionary of students and their respective scores.
Add a new student and score to the dictionary.
Update the score of an existing student.
Delete a student from the dictionary.
Calculate the average score of all students.
Find the highest and lowest score and the student(s) associated with those scores.
Sort the dictionary by student names and by scores.
Print the dictionary in a readable format.


_________________________________________________________________________________



Mode
Meaning
r
Read (default)
w
Write (overwrite or create)
a
Append
x
Create file, error if exists
r+
Read + Write
w+
Write + Read
a+
Append + Read
t
Text mode (default)



__________________


data.txt

Hello World
Hello Coders


______________________


f = open("data.txt", "r")
content = f.read()
print(content)
f.close() 


read()
Reads entire file.
f = open("data.txt", "r")
content = f.read()
print(content)
f.close() 
read(n)
Reads n characters.
f = open("data.txt")
print(f.read(10))
f.close()



readline()
Reads one line.

f = open("data.txt")
line = f.readline()
print(line)
f.close()


readlines()
Reads all lines into a list.


f = open("data.txt")
lines = f.readlines()
print(lines)
f.close()




write()


f = open("data2.txt", "w")
f.write("Hello Python\n")
f.write("File handling")
f.close()


w mode overwrites existing content.
writelines()


lines = ["Line 1\n", "Line 2\n"]
f = open("data2.txt", "w")
f.writelines(lines)
f.close()


Appending to a File


f = open("data2.txt", "a")
f.write("\nNew line added")
f.close()




A file object is an iterator.


f = open("data.txt")

for line in f:
    print(line.strip())

f.close()



Benefits:
Memory efficient
Best for large files



Using try-finally
Ensures the file is always closed, even if an error occurs.


f = None
try:
    f = open("data.txt", "r")
    print(f.read())
finally:
    if f:
        f.close()
Problem:
Verbose
Easy to forget close()



Using Context Manager (with statement) :
Automatically handles opening & closing.

with open("data.txt", "r") as f:
    content = f.read()
    print(content)


File closes automatically; Cleaner; Safer
Writing with Context Manager

with open("data2.txt", "w") as f:
    f.write("Using context manager")

Reading Line by Line (Best Pattern)

with open("data.txt") as f:
    for line in f:
        print(line.strip())


Ideal for:
Logs
Large datasets
Streaming data



Example handling:
try:
    with open("missing.txt") as f:
        print(f.read())
except FileNotFoundError:
    print("File not found")


Error
Cause
FileNotFoundError
File doesn't exist
PermissionError
No access rights
ValueError
File already closed





________________________________________________________

A module is just a .py file.
File: calculator.py
def add(a, b):
    return a + b

def subtract(a, b):
    return a - b

def div(a, b):
    return a / b

def mul(a, b):
    return a * b





Imports the entire module.
Use the module in another file
File: main.py


import calculator

print(calculator.add(10, 5))       # 15
print(calculator.subtract(10, 5))  # 5


Access using module_name.function_name



Import specific functions

from calculator import add

print(add(20, 30))  # 50


Cleaner
Only add is available




from calculator import add

print(add(10, 5))       # 15
# print(subtract(10, 5))  # 5






from calculator import add, subtract

print(add(10, 5))       # 15
print(subtract(10, 5))  # 5



Import all functions


from calculator import *

print(add(20, 30))  # 50
print(mul(20, 30))  # 600




Cleaner
All functions are available




from calculator import *

print(add(10, 5))       # 15
print(subtract(10, 5))  # 5



Import with alias


import calculator as calc

print(calc.add(7, 3))  # 10


Shorter name




Get all functions from a file
import hello

print(hello.__dict__.keys())




Using if __name__ == "__main__"

calculator.py
def add(a, b):
    return a + b

if __name__ == "__main__":
    print(add(2, 3))  # runs only if file is executed directly
main.py
import calculator

print(calculator.add(10, 20))






def add(a, b):
    return a + b

def subtract(a, b):
    return a - b

def div(a, b):
    return a / b

def mul(a, b):
    return a * b

if __name__ == "__main__":
    print("I am in the calculator")
    print(add(6,8))



from calculator import *

print(add(20, 30))  # 50
print(mul(20, 30))  # 600



________________________

Folder Structure:
project/
 ├── main.py
 └── mypackage/
     ├── __init__.py
     ├── calculator.py
     └── math_ops.py

Create Python files (modules).
mypackage/calculator.py

    def add(a, b):
        return a + b
    
    def subtract(a, b):
        return a - b

mypackage/math_ops.py

    def multiply(a, b):
        return a * b
    
    def divide(a, b):
        return a / b



Create a file outside the package.
main.py

    from mypackage.calculator import add, subtract
    from mypackage.math_ops import multiply
    
    print(add(10, 5))        # 15
    print(subtract(10, 5))   # 5
    print(multiply(4, 3))    # 12




You can expose only selected functions.
mypackage/__init__.py

    from .calculator import add
    from .math_ops import multiply


main.py

    from mypackage import add, multiply
    
    print(add(2, 3))
    print(multiply(3, 4))
Clean API
Very Pythonic



Using __all__
Controls what is imported using:
from module import *
Example
# my_module.py
# __all__ = ['add']
__all__ = ["add", "subtract"]

def add(a, b):
    return a + b

def subtract(a, b):
    return a - b
Usage:
from my_module import *
add(2, 3)        # OK
subtract(5, 2)   # NameError
Without __all__, names starting with _ are ignored.




__all__ = ["add", "subtract"]

def add(a, b):
    return a + b

def subtract(a, b):
    return a - b

def div(a, b):
    return a / b

def mul(a, b):
    return a * b

if __name__ == "__main__":
    print("I am in the calculator")
    print(add(6,8))






main.py

from calculator import *
add(2, 3)        # OK
mul(5, 2)   # NameError



________________________________________________



Python exceptions form a class hierarchy.
BaseException
├── SystemExit
├── KeyboardInterrupt
├── GeneratorExit
└── Exception
     ├── ArithmeticError
     │    ├── ZeroDivisionError
     │    └── OverflowError
     ├── LookupError
     │    ├── IndexError
     │    └── KeyError
     ├── ValueError
     ├── TypeError
     ├── FileNotFoundError
     ├── ImportError
     ├── AttributeError
     └── RuntimeError




_____________________


Basic try–except

try:
    x = int("10")
    y = 10 / 0
except ZeroDivisionError:
    print("Cannot divide by zero")

Handling Multiple Exceptions

try:
    num = int(input("Enter number: "))
    print(10 / num)
except ValueError:
    print("Invalid input")
except ZeroDivisionError:
    print("Division by zero")


Single except for Multiple Exceptions

except (ValueError, ZeroDivisionError):
    print("Input error")

Catching All Exceptions

except Exception as e:
    print(e)

Use sparingly—can hide bugs.




else
Executes only if no exception occurs.

try:
    print(10 / 2)
except ZeroDivisionError:
    print("Error")
else:
    print("Success")


finally
Executes always, used for cleanup.


try:
    f = open("data.txt")
except FileNotFoundError:
    print("File missing")
finally:
    print("Cleanup")



try:
    num = int(input("Enter number: "))
    print(10 / num)
except ZeroDivisionError:
    print("Div by Error")
except ValueError:
    print("Invalid input")
else:
    print("Success")
finally:
    print("Cleanup")





Using raise

if age < 18:
    raise ValueError("Age must be 18+")


Re-raising Exception


except Exception:
    raise


Example:
try:
    num = int(input("Enter age: "))
    print("Age:" + str(num))
    if num < 18:
        raise ValueError("Age must be 18+")
# except ValueError as e:
#     print("Invalid age")
#     print(e)
except Exception:
    raise # raise the same exception
else:
    print("Valid Age for Emp")












